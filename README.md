# config-management-REPL

Небольшой учебный REPL-эмулятор UNIX-подобной командной строки с виртуальной файловой системой (VFS) в памяти.  
Поддерживает запуск в интерактивном режиме и исполнение стартовых скриптов.

## Содержание
- [Фичи](#фичи)
- [Структура проекта](#структура-проекта)
- [Сборка и запуск](#сборка-и-запуск)
- [Флаги запуска](#флаги-запуска)
- [Команды REPL](#команды-repl)
- [Стартовые скрипты](#стартовые-скрипты)
- [VFS (формат JSON)](#vfs-формат-json)
- [Ограничения и заметки](#ограничения-и-заметки)
- [Планы/ToDo](#планыtodo)

## Фичи
- VFS хранится **в памяти**, загружается из **JSON** (есть дефолтное дерево).
- Интерактивный REPL + **скриптовый режим** (файл с командами).
- Базовые команды командной строки:  
  `ls`, `cd`, `echo`, `exit`, `clear`, `uname`, `uniq`, `cat`, `touch`, `vfs-load`.
- Безопасная навигация по VFS (`resolvePath`, проверка типов узлов).

## Структура проекта
```
cmd/
  shell/
    main.go            # входная точка: запуск REPL
internal/
  repl/                # цикл REPL, парсинг флагов, режим скрипта
  parser/              # разбор строки команды (имя + аргументы)
  prompt/              # построение промпта (user@host:/path$)
  vfs/                 # виртуальная ФС: загрузка из JSON, операции
  commands/            # команды и их реестр
    model/             # Env, интерфейс Command
    registry/          # регистрация команд по имени
start_scripts/
  start_script_1       # базовый сценарий (ls, cd, echo, exit)
  start_script_2       # сценарий с VFS/флагами (и/или vfs-load)
  start_script_3       # расширенный сценарий (touch, clear и др.)
internal/vfs/vfs_default.json  # дефолтная VFS
go.mod
```

## Сборка и запуск

Требуется Go ≥ 1.21 (подставь свою версию).

```bash
# Сборка
go build -buildvcs=false -o bin/shell ./cmd/shell

# Интерактивный режим с дефолтной VFS
./bin/shell -vfs internal/vfs/vfs_default.json

# Скриптовый режим
./bin/shell -vfs internal/vfs/vfs_default.json -script start_scripts/start_script_1
```

> `-buildvcs=false` отключает встраивание VCS-метаданных, если git недоступен.

## Флаги запуска
- `-vfs <path>` — путь к JSON-файлу виртуальной ФС. Если не указан, будет использована дефолтная VFS.
- `-script <path>` — путь к стартовому скрипту. Команды выполняются по строкам; пустые строки и строки, начинающиеся с `#`, пропускаются. На экране отображаются и ввод, и вывод.

При старте REPL выводит значения полученных флагов в отладочном виде.

## Команды REPL

| Команда             | Описание |
|---------------------|----------|
| `ls [path]`         | Список содержимого директории (текущей или указанной). |
| `cd <path>`         | Сменить каталог. Поддерживает абсолютные и относительные пути. |
| `echo <text>`       | Печать текста. |
| `exit`              | Завершение работы REPL. |
| `clear`             | Очистка экрана (ANSI: `\x1b[2J\x1b[H`). |
| `uname`             | Имя ОС (упрощённо). Опционально `-a` для расширенной строки. |
| `cat <file>`        | Вывести содержимое текстового файла из VFS. |
| `uniq <file>`       | Удалить подряд идущие дубликаты строк в файле и вывести результат. |
| `touch <name>`      | Создать пустой файл в текущем каталоге (если существует — no-op). |
| `vfs-load <path>`   | Загрузить новую VFS из JSON **без перезапуска** (заменяет текущее дерево в памяти). |

## Стартовые скрипты

Формат: по одной команде на строку. Пустые/комментарии (`# ...`) пропускаются.

`start_scripts/start_script_1` (пример):
```
# базовая навигация
ls
cd /home
ls
echo Hello from VFS
exit
```

Запуск:
```bash
./bin/shell -vfs internal/vfs/vfs_default.json -script start_scripts/start_script_1
```

## VFS (формат JSON)

Минимальный пример `internal/vfs/vfs_default.json`:
```json
{
  "name": "/",
  "type": "dir",
  "children": [
    {
      "name": "home",
      "type": "dir",
      "children": [
        {
          "name": "user",
          "type": "dir",
          "children": [
            {
              "name": "readme.txt",
              "type": "file",
              "contentText": "Добро пожаловать в виртуальную FS!"
            }
          ]
        }
      ]
    },
    {
      "name": "etc",
      "type": "dir",
      "children": [
        {
          "name": "config.json",
          "type": "file",
          "contentText": "{ \"version\": \"1.0\" }"
        }
      ]
    },
    {
      "name": "docs",
      "type": "dir",
      "children": [
        {
          "name": "manual.txt",
          "type": "file",
          "contentText": "Это пример документации."
        }
      ]
    }
  ]
}
```

Требования/валидации VFS:
- `type`: `"dir"` или `"file"`.
- Файлы не могут иметь `children`.
- Внутри одной директории имена детей уникальны.
- Допускается `contentText` (для текстовых файлов). Для бинарного содержимого можно использовать `contentBase64`.

## Ограничения и заметки
- Все операции происходят **в памяти**. Модификации не пишутся обратно в JSON (если не делать этого явно).
- Права пользователей, владельцы, время модификации и т.п. не моделируются.
- Редиректы (`>`, `>>`) и пайпы (`|`) не обрабатываются (можно добавить позже на уровне REPL/парсера).

## Планы/ToDo
- Редиректы вывода (`echo "hi" > file.txt`) и пайпы (`cat a | uniq`).
- Дополнительные команды (`mkdir`, `rm`, `mv`, `cp`).
- Сохранение изменённой VFS в JSON по команде (`vfs-save <path>`).
- Тесты на команды и VFS (unit + e2e для скриптового режима).
